// Auto-generated from cascade.html.
// DO NOT EDIT.

library cascade_html;

import 'dart:html' as autogenerated;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;
import 'package:web_ui/observe/observable.dart' as __observe;
import '_from_packages/widget/components/dropdown.dart';
import 'xgamecell.dart';
import 'dart:html';
import 'dart:math';
import 'package:web_ui/web_ui.dart';
import 'dart:json';
import 'package:widget/widget.dart';


// Original code


// initial value for click-counter
int startingCount = 5;
Board board;
List<Board> historyStack = new List<Board>();
int score;
int boardW;
int boardH;
bool isGameOver;
bool boardClear;
int numColours;

class Board{
  List<List<Cell>> cells;
  Board(int width, int height){
    var rng = new Random();
    cells = new List<List<Cell>>.generate(height, (i)=>new List<Cell>.generate(width,(j)=>new Cell(rng.nextInt(numColours)+1,i,j)));
  }
  int getContentYx(Yx cd) => getContent(cd.y,cd.x);
  int getContent(int y, int x) => cells[y][x].contents;
  int setContent(int y,int x, int value) => cells[y][x].contents = value;
  int setContentYx(Yx cd, int value) => setContent(cd.y,cd.x,value);
  String toString() => stringify(cells);
  bool isEmpty() => cells.every((List<Cell> r)=>r.every((cell)=>cell.contents==0));
  bool noMoves() => !cells.any((List<Cell> r)=>r.any((cell)=>hasMinimumChain(cell.row,cell.col)));
}

class Cell {
  int contents=0;
  int row;
  int col;
  Cell(this.contents,this.row,this.col);
  String toString() => contents.toString(); 
  String toJson() => contents.toString();
}

class Yx {
  int y;int x;
  Yx(this.y,this.x);
  bool operator==(other) => (x==other.x) && (y==other.y);
  int get hashCode{return x.hashCode;}
  String toString() => "(y$y,x$x)";
  List<Yx> adjacent() => [new Yx(y,x+1),new Yx(y,x-1),new Yx(y+1,x),new Yx(y-1,x)];
  Iterable validAdjacent() => adjacent().where((Yx yx)=>(yx.x>=0) && (yx.y>=0) && (yx.y<boardH) && (yx.x<boardW));
}

void main() {
  // Enable this to use Shadow DOM in the browser.
  //useShadowDom = true;
  newGame();
}

void newGame({int width:9,int height:7, int colours:3}){
  Dropdown.closeDropdowns();
  score=0;
  boardW=width;
  boardH=height;
  numColours=colours;
  boardClear=false;
  board = new Board(boardW,boardH);
  isGameOver = false;
}

void clicked(int row, int col){
  List<Yx> chain = generateChain(row,col);
  if(chain.length>1){
    //window.alert(board.toString());
    score+=(chain.length * (chain.length-1))+1;
    chain.forEach((yx)=>board.setContentYx(yx, 0));
    gravity();
    horizontalGravity();
    checkGameOver();
  }
}

void gravity(){
  bool changed = true;
  while(changed){
    changed = false;
    for(int r = (boardH-2); r >= 0 ; r--){
      for(int c =0; c < boardW; c++) {
        if(board.getContent(r, c)!=0 && board.getContent(r+1, c)==0){
          board.setContent(r+1, c, board.getContent(r, c));
          board.setContent(r, c, 0);
          changed = true;
        }
      }
    }
  }
}

void horizontalGravity(){
  bool changed = true;
    while(changed){
    changed = false;
    for( int c=1; c < boardW; c++) {
      if(board.getContent(boardH-1, c)!=0 && board.getContent(boardH-1, c-1)==0){
        //slide entire column left
        for (int r=0; r < boardH; r++){
          board.setContent(r, c-1, board.getContent(r, c));
          board.setContent(r, c, 0);
          changed = true;
        }
      }
    }
  }
}

void checkGameOver (){
  if(board.isEmpty()) {
    score += boardW*boardH*3;
    boardClear = true;
    isGameOver=true;
  }
  if (board.noMoves()){
    isGameOver=true;
  }
}

List<Yx> generateChain(int startRow, int startCol){
  List<Yx> selected = new List<Yx>();
  List<Yx> agenda = new List<Yx>();
  List<Yx> searched = new List<Yx>();
  Yx current;
  int contentType = board.getContent(startRow,startCol);
  if (contentType==0) return selected;//Not valid chain
  agenda.add(new Yx(startRow,startCol));
  
  while (agenda.length > 0){
    current = agenda.last;
    if(board.getContentYx(current) == contentType){
      selected.add(current);
      bool isValid(Yx yx) => !selected.contains(yx);
      current.validAdjacent().where(isValid).forEach((Yx yx)=>agenda.add(yx));
    }
    searched.add(current);
    agenda.remove(current);
  }
  return selected;
}

bool hasMinimumChain(int row, int col){
  int contentType = board.getContent(row,col);
  if (contentType==0) return false;
  return (new Yx(row,col)).validAdjacent().any((Yx yx)=>board.getContentYx(yx)==contentType);
}
// Additional generated code
void init_autogenerated() {
  var __root = autogenerated.document.body;
  final __html0 = new autogenerated.TableRowElement(), __html1 = new autogenerated.Element.html('<td>\n              <div is="x-game-cell"></div>\n            </td>'), __html2 = new autogenerated.Element.html('<span>Score: </span>'), __html3 = new autogenerated.Element.html('<span style="display:none"></span>'), __html4 = new autogenerated.Element.html('<span style="float:right" template="" instantiate="if isGameOver &amp;&amp; !boardClear">Game Over!</span>'), __html5 = new autogenerated.Element.html('<span style="display:none"></span>'), __html6 = new autogenerated.Element.html('<span style="float:right" template="" instantiate="if isGameOver &amp;&amp; boardClear">Complete Victory!</span>');
  var __e0, __e1, __e10, __e11, __e2, __e3, __e7, __e9;
  var __t = new autogenerated.Template(__root);
  __e3 = __root.nodes[3];
  __e0 = __e3.nodes[3].nodes[1];
  __t.listen(__e0.onClick, ($event) { newGame(); });
  __e1 = __e3.nodes[3].nodes[3];
  __t.listen(__e1.onClick, ($event) { newGame(width:14,height:9,colours:4); });
  __e2 = __e3.nodes[3].nodes[5];
  __t.listen(__e2.onClick, ($event) { newGame(width:20,height:12,colours:5); });
  __t.component(new Dropdown()..host = __e3);
  __e7 = __root.nodes[5].nodes[1];
  __t.loopIterateAttr(__e7, () => board.cells, ($list, $index, __t) {
    var row = $list[$index];
    var __e6;
    __e6 = __html0.clone(true);
    __t.loopIterateAttr(__e6, () => row, ($list, $index, __t) {
      var cell = $list[$index];
      var __e4, __e5;
      __e5 = __html1.clone(true);
      __e4 = __e5.nodes[1];
      __t.listen(__e4.onClick, ($event) { clicked(cell.row,cell.col); });
      __t.oneWayBind(() => cell.contents, (e) { if (__e4.xtag.contents != e) __e4.xtag.contents = e; }, false, false);
      __t.component(new CellComponent()..host = __e4);
    __t.addAll([new autogenerated.Text('\n            '),
        __e5,
        new autogenerated.Text('\n          ')]);
    });
  __t.addAll([new autogenerated.Text('\n          '),
      __e6,
      new autogenerated.Text('\n        ')]);
  });
  __e11 = __root.nodes[7];
  var __binding8 = __t.contentBind(() => score, false);
  __e9 = __html3.clone(true);
  __t.conditional(__e9, () => isGameOver && !boardClear, (__t) {
  __t.add(__html4.clone(true));
  });

  __e10 = __html5.clone(true);
  __t.conditional(__e10, () => isGameOver && boardClear, (__t) {
  __t.add(__html6.clone(true));
  });

  __e11.nodes.addAll([new autogenerated.Text('\n      '),
      __html2.clone(true),
      __binding8,
      new autogenerated.Text('\n      '),
      __e9,
      new autogenerated.Text('\n      '),
      __e10,
      new autogenerated.Text('\n    ')]);
  __t.create();
  __t.insert();
}

//@ sourceMappingURL=cascade.dart.map